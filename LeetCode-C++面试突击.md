# 编译内存相关

## C++ 程序编译过程

编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。

- 编译预处理：处理以 # 开头的指令；

- 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；

- 汇编：将汇编代码 .s 翻译成机器指令 .o 文件；

- 链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。


![](.\images\1 C++程序编译过程.png)

链接分为两种：

**静态链接**：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。
**动态链接**：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。
二者的优缺点：

静态链接：**浪费空间**，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（**更新困难**）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。



静态链接是将程序调用的库一起打包到可执行文件中，这样执行时就不需要调用别的库了，速度快，但是链接的时候可能同一个库链接了好几次，导致空间浪费，而且如果该库更新了的话，整个程序需要重新编译；

![](.\images\2 静态链接.png)

动态链接是在程序执行时才载入引用的库，因此方便更新。

<img src=".\images\3 动态链接.png" style="zoom: 33%;" />

## C++ 内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

- **栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
- **堆**：动态申请的内存空间，就是由 **malloc**分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。**new生成的对象也是分配在堆上的**
- **全局区/静态存储区（.bss 段和 .data 段）**：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- **常量存储区（.data 段）**：存放的是常量，不允许修改，程序运行结束自动释放。
- **代码区（.text 段）**：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

说明：

从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env
程序实例：

```c++
#include <iostream>
using namespace std;

/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/

int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```

![](.\images\4 linux虚拟内存系统地址空间分配.png)

## 栈和堆的区别

- 申请方式：**栈是系统自动分配，堆是程序员主动申请**。
- 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；**申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除**，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
- **栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的**。
- 申请效率：**栈是有系统自动分配，申请效率高**，但程序员无法控制；**堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片**。
- 存放的内容：栈中存放的是局部变量，函数的参数，返回地址等；堆中存放的内容由程序员控制，是由malloc分配。

<img src=".\images\5 堆内存为什么不连续.png" style="zoom:50%;" />

## 变量的区别

**全局变量、局部变量、静态全局变量、静态局部变量的区别**
C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

从作用域看：

- **全局变量**：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。
- **静态全局变量**：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
- **局部变量**：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
- **静态局部变量**：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

从分配内存空间看：

**静态存储区：全局变量，静态局部变量，静态全局变量。**
**栈：局部变量。**

说明：

静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：**静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。**
静态变量和全局变量的区别：***静态变量用 static 告知编译器，自己仅仅在变量的作用范围内可见***。

